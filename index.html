<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Zygolabs Beta</title>
<script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>

<style>
body{background:#0b0b0b;color:white;font-family:Arial;text-align:center;padding:20px;}
canvas{margin-top:20px;border-radius:10px;}
.metrics{margin-top:20px;font-size:14px;line-height:1.6;}
.slider-box{margin:14px auto;width:90%;text-align:left;cursor:pointer;}
.slider-label{font-size:13px;margin-bottom:6px;}
.slider-track{position:relative;height:16px;border-radius:10px;overflow:hidden;}
.slider-marker{position:absolute;top:-10px;width:6px;height:36px;background:white;border-radius:2px;box-shadow:0 0 10px #00ffea;z-index:5;}
.value-text{font-size:12px;margin-top:5px;color:#ccc;}
#graph{margin-top:30px;background:#111;border-radius:10px;}
</style>
</head>

<body>

<h1>Zygolabs Beta Test by @changfrommumbai</h1>
<input type="file" id="upload" accept="image/*"><br>
<canvas id="canvas"></canvas>

<div class="metrics" id="metrics">Loading AI models...</div>
<canvas id="graph" width="650" height="260"></canvas>

<script>
window.addEventListener("load", async () => {

  const upload = document.getElementById("upload");
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const metrics = document.getElementById("metrics");
  const graph = document.getElementById("graph");
  const gctx = graph.getContext("2d");

  await faceapi.nets.tinyFaceDetector.loadFromUri('models');
  await faceapi.nets.faceLandmark68Net.loadFromUri('models');

  metrics.innerText = "Zygolabs is ready! Please upload a front facing picture with neutral expression and lightning else rating can fluctute";

  let currentLandmarks = null;
  let imgCache = null;

  /* ===== MATH UTILS ===== */
  function distance(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }

  function eyeCenter(eye) {
    return {
      x: eye.reduce((s, p) => s + p.x, 0) / eye.length,
      y: eye.reduce((s, p) => s + p.y, 0) / eye.length
    };
  }

  function strictRangeScore(value, min, max) {
    if (value >= min && value <= max) return 1;
    const ideal = (min + max) / 2;
    const dev = Math.abs(value - ideal);
    const rangeHalf = (max - min) / 2;
    // Super forgiving dropoff so good-but-not-perfect faces don't get nuked
    return Math.max(0, 1 - Math.pow(dev / (rangeHalf * 3), 1.6));
  }

  function degrees(rad) { return rad * (180 / Math.PI); }

  /* ===== SLIDER COMPONENT ===== */
  function sliderHTML(name, value, idealMin, idealMax, fullMin, fullMax, key) {
    const norm = (value - fullMin) / (fullMax - fullMin);
    const pos = Math.max(0, Math.min(100, norm * 100));
    const g1 = ((idealMin - fullMin) / (fullMax - fullMin)) * 100;
    const g2 = ((idealMax - fullMin) / (fullMax - fullMin)) * 100;

    let displayValue = value.toFixed(3);
    if (key.includes('Sym') || key.includes('Tilt') || key.includes('Third') || key.includes('Aspect')) {
      displayValue = value.toFixed(2);
    }

    return `
    <div class="slider-box" data-key="${key}">
      <div class="slider-label">${name}</div>
      <div class="slider-track" style="background: linear-gradient(to right, #ff2e2e 0%, #ffae00 ${g1}%, #00ff6a ${g1}%, #00ff6a ${g2}%, #ffae00 ${g2}%, #ff2e2e 100%)">
        <div class="slider-marker" style="left:${pos}%"></div>
      </div>
      <div class="value-text">${displayValue}</div>
    </div>`;
  }

  /* ===== SCORE GRAPH ===== */
  function drawGraph(score) {
    gctx.clearRect(0, 0, graph.width, graph.height);
    gctx.strokeStyle = "#444";
    gctx.beginPath();
    gctx.moveTo(40, 220);
    gctx.lineTo(610, 220);
    gctx.stroke();

    gctx.strokeStyle = "#00ff6a";
    gctx.beginPath();
    for (let x = 0; x <= 10; x += 0.05) {
      let px = 40 + (x / 10) * 570;
      let y = Math.exp(-Math.pow(x - 5, 2) / 4);
      let py = 220 - (y * 150);
      if (x === 0) gctx.moveTo(px, py); else gctx.lineTo(px, py);
    }
    gctx.stroke();

    let ux = 40 + (score / 10) * 570;
    let uy = 220 - (Math.exp(-Math.pow(score - 5, 2) / 4) * 150);
    gctx.fillStyle = "red";
    gctx.beginPath();
    gctx.arc(ux, uy, 7, 0, 2 * Math.PI);
    gctx.fill();
    gctx.fillStyle = "white";
    gctx.fillText("YOU", ux - 12, uy - 12);
  }

  /* ===== MAIN ANALYSIS ===== */
  upload.addEventListener("change", async () => {
    const file = upload.files[0];
    if (!file) return;

    const img = await faceapi.bufferToImage(file);
    imgCache = img;

    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);

    metrics.innerText = "Scanning skull for halos & failos ðŸ’€ ...";

    const detection = await faceapi
      .detectSingleFace(img, new faceapi.TinyFaceDetectorOptions({ inputSize: 640 }))
      .withFaceLandmarks();

    if (!detection) {
      metrics.innerText = "No face detected ðŸ¤¡ Better pic or touch grass";
      return;
    }

    const l = detection.landmarks;
    currentLandmarks = l;

    const jaw = l.getJawOutline();
    const leftEye = l.getLeftEye();
    const rightEye = l.getRightEye();
    const mouth = l.getMouth();
    const nose = l.getNose();
    const leftBrow = l.getLeftEyeBrow();
    const rightBrow = l.getRightEyeBrow();

    const leftCenter = eyeCenter(leftEye);
    const rightCenter = eyeCenter(rightEye);

    const interpupillary = distance(leftCenter, rightCenter);
    const bizygomatic = distance(jaw[0], jaw[16]);
    const faceHeight = distance(jaw[8], leftBrow[2]);

    const midBrow = {
      x: (leftBrow[3].x + rightBrow[1].x) / 2,
      y: (leftBrow[3].y + rightBrow[1].y) / 2
    };

    const upperLipY = mouth[3].y;

    /* ===== CORE RATIOS (your originals) ===== */
    const FWHR = bizygomatic / (upperLipY - midBrow.y);
    const midfaceRatio = interpupillary / (upperLipY - midBrow.y);
    const mouthWidth = distance(mouth[0], mouth[6]);
    const noseWidth = distance(nose[0], nose[4]);
    const mouthNoseRatio = mouthWidth / noseWidth;
    const upperLipHeight = distance(mouth[3], mouth[2]);
    const lowerLipHeight = distance(mouth[3], mouth[4]);
    const lipRatio = (lowerLipHeight / upperLipHeight) * 1.6;
    const chinHeight = jaw[8].y - mouth[3].y;
    const philtrumHeight = mouth[3].y - nose[3].y;
    const chinPhiltrumRatio = chinHeight / philtrumHeight;
    const ESR = interpupillary / bizygomatic;

    const jawWidthRatio = bizygomatic / faceHeight;
    const lowerFaceRatio = (jaw[8].y - mouth[3].y) / faceHeight;
    const eyeSeparationRatio = interpupillary / faceHeight;
    const noseLengthRatio = distance(nose[3], midBrow) / faceHeight;
    const faceHeightRatio = faceHeight / bizygomatic;
    const jawSymmetry = Math.abs(distance(jaw[8], jaw[4]) - distance(jaw[8], jaw[12])) / bizygomatic;
    const eyeSymmetry = Math.abs(distance(leftEye[0], leftEye[3]) - distance(rightEye[0], rightEye[3])) / interpupillary;
    const browHeightRatio = (midBrow.y - leftEye[1].y) / faceHeight;
    const noseProjectionRatio = distance(nose[3], nose[6]) / noseWidth;

    /* ===== NEW HIGH-IMPACT RATIOS ===== */
    // Canthal Tilt (positive = hunter eyes halo)
    const leftCT = degrees(Math.atan2(leftEye[4].y - leftEye[0].y, leftEye[4].x - leftEye[0].x));
    const rightCT = degrees(Math.atan2(rightEye[4].y - rightEye[0].y, rightEye[4].x - rightEye[0].x));
    const canthalTilt = (leftCT + rightCT) / 2;

    // Eye Aspect Ratio (PFL / PFH, almond shape ideal)
    const leftPFL = distance(leftEye[0], leftEye[4]);
    const rightPFL = distance(rightEye[0], rightEye[4]);
    const leftPFH = distance(leftEye[1], leftEye[5]);
    const rightPFH = distance(rightEye[1], rightEye[5]);
    const eyeAspectRatio = ((leftPFL / leftPFH) + (rightPFL / rightPFH)) / 2;

    // Lower Third % (masc dominant lower face)
    const upperThirdApprox = distance(midBrow, leftEye[1]); // rough proxy
    const midThird = upperLipY - midBrow.y;
    const lowerThird = jaw[8].y - upperLipY;
    const totalApproxHeight = upperThirdApprox + midThird + lowerThird;
    const lowerThirdPct = (lowerThird / totalApproxHeight) * 100;

    // Cheekbone Ratio (forward projection + high set)
    const cheekboneRatio = bizygomatic / faceHeight;

    /* ===== SCORES ===== */
    const scores = {
      FWHR: strictRangeScore(FWHR, 1.70, 1.77),
      midface: strictRangeScore(midfaceRatio, 0.74, 0.79),
      mouthNose: strictRangeScore(mouthNoseRatio, 1.13, 1.17),
      lips: strictRangeScore(lipRatio, 1.60, 1.67),
      chinPhil: strictRangeScore(chinPhiltrumRatio, 1.92, 1.98),
      ESR: strictRangeScore(ESR, 0.435, 0.45),

      jawWidth: strictRangeScore(jawWidthRatio, 1.02, 1.06),
      lowerFace: strictRangeScore(lowerFaceRatio, 0.33, 0.36),
      eyeSep: strictRangeScore(eyeSeparationRatio, 0.45, 0.47),
      noseLen: strictRangeScore(noseLengthRatio, 0.41, 0.435),
      faceH: strictRangeScore(faceHeightRatio, 0.94, 0.98),

      jawSym: strictRangeScore(jawSymmetry, 0, 0.012),
      eyeSym: strictRangeScore(eyeSymmetry, 0, 0.012),
      browH: strictRangeScore(browHeightRatio, -0.11, -0.09),
      noseProj: strictRangeScore(noseProjectionRatio, 0.20, 0.225),

      // NEW HIGH IMPACT
      canthalTilt: strictRangeScore(canthalTilt, 3, 8),
      eyeAspect: strictRangeScore(eyeAspectRatio, 2.8, 3.6),
      lowerThirdPct: strictRangeScore(lowerThirdPct, 32, 37),
      cheekboneRatio: strictRangeScore(cheekboneRatio, 0.70, 0.85)
    };

    /* ===== WEIGHTS ===== */
    const weights = {
      FWHR: 1.35,
      midface: 1.55,
      chinPhil: 1.15,
      mouthNose: 0.65,
      ESR: 1.25,
      lips: 0.55,

      jawWidth: 1.1,
      lowerFace: 1.0,
      eyeSep: 0.7,
      noseLen: 0.65,
      faceH: 1.1,

      jawSym: 1.15,
      eyeSym: 1.1,
      browH: 0.75,
      noseProj: 0.85,

      canthalTilt: 1.45,     // positive tilt is massive halo
      eyeAspect: 1.35,       // almond eyes carry hard
      lowerThirdPct: 1.2,    // tall lower third masc af
      cheekboneRatio: 1.3    // forward/high cheeks = chad
    };

    let total = 0, weightSum = 0;
    for (let k in scores) {
      total += scores[k] * weights[k];
      weightSum += weights[k];
    }
    let finalScore = (total / weightSum) * 10;

    /* ===== UI OUTPUT ===== */
    metrics.innerHTML = `
      <h3>Your Ratios:</h3>

      ${sliderHTML("FWHR", FWHR, 1.70, 1.77, 1.4, 2.2, "FWHR")}
      ${sliderHTML("Midface Ratio", midfaceRatio, 0.74, 0.79, 0.65, 1.0, "midface")}
      ${sliderHTML("Mouth:Nose", mouthNoseRatio, 1.13, 1.17, 1.0, 1.8, "mouthNose")}
      ${sliderHTML("Lip Ratio", lipRatio, 1.60, 1.67, 1.2, 2.2, "lips")}
      ${sliderHTML("Chin:Philtrum", chinPhiltrumRatio, 1.92, 1.98, 1.5, 2.8, "chinPhil")}
      ${sliderHTML("ESR", ESR, 0.435, 0.45, 0.38, 0.52, "ESR")}

      ${sliderHTML("Jaw Width Ratio", jawWidthRatio, 1.02, 1.06, 0.85, 1.15, "jawWidth")}
      ${sliderHTML("Lower Face Ratio", lowerFaceRatio, 0.33, 0.36, 0.28, 0.42, "lowerFace")}
      ${sliderHTML("Eye Sep Ratio", eyeSeparationRatio, 0.45, 0.47, 0.40, 0.55, "eyeSep")}
      ${sliderHTML("Nose Len Ratio", noseLengthRatio, 0.41, 0.435, 0.35, 0.50, "noseLen")}
      ${sliderHTML("Face H Ratio", faceHeightRatio, 0.94, 0.98, 0.85, 1.15, "faceH")}

      ${sliderHTML("Canthal Tilt Â°", canthalTilt, 3, 8, -5, 15, "canthalTilt")}
      ${sliderHTML("Eye Aspect Ratio", eyeAspectRatio, 2.8, 3.6, 2.0, 4.5, "eyeAspect")}
      ${sliderHTML("Lower Third %", lowerThirdPct, 32, 37, 25, 45, "lowerThirdPct")}
      ${sliderHTML("Cheekbone Ratio", cheekboneRatio, 0.70, 0.85, 0.6, 1.0, "cheekboneRatio")}

      ${sliderHTML("Jaw Sym", jawSymmetry * 100, 0, 1.2, 0, 5, "jawSym")}
      ${sliderHTML("Eye Sym", eyeSymmetry * 100, 0, 1.2, 0, 5, "eyeSym")}
      ${sliderHTML("Brow Height", browHeightRatio, -0.11, -0.09, -0.15, 0.05, "browH")}
      ${sliderHTML("Nose Proj", noseProjectionRatio, 0.20, 0.225, 0.15, 0.35, "noseProj")}

      <h2>ðŸ”¥ FINAL BLACKPILL SCORE: ${finalScore.toFixed(2)} / 10</h2>
    `;

    drawGraph(finalScore);
  });
});
</script>

</body>
</html>
